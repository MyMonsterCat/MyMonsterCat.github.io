import{_ as t,X as n,Y as h,$ as a,a0 as s,Z as o,a1 as l,D as r}from"./framework-0ece11a6.js";const i={},c=l('<h2 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h2><h3 id="_1-hashmap的底层实现是什么" tabindex="-1"><a class="header-anchor" href="#_1-hashmap的底层实现是什么" aria-hidden="true">#</a> 1.HashMap的底层实现是什么？</h3><ul><li>JDK1.8之前：数组 + 链表</li></ul><blockquote><p>即拉链法，也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的 值加到链表中即可。</p></blockquote><ul><li>JDK1.8之后：<strong>数组 + （链表 | 红黑树）</strong></li></ul><h3 id="_2-树化与退化" tabindex="-1"><a class="header-anchor" href="#_2-树化与退化" aria-hidden="true">#</a> 2.树化与退化</h3><ul><li>树化规则：<strong>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;=64，才会进行树化</strong></li><li>退化规则： <ul><li>数组扩容时，会重新计算索引位置，也就是原本的树结构可能会变，如果<strong>重新计算后的树元素个数 &lt;= 6 则会退化为链表</strong></li><li>移除树节点时，如果root、root.left、root.right、root.left.left有一个为 null ，退化为链表</li></ul></li></ul>',7),p=a("blockquote",null,[a("p",null,"树化的意义是什么？"),a("p",null,"​ 红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略"),a("p",null,"为什么一上来不树化？"),a("p",null,[s("​ 哈希表的查找、更新的时间复杂度是 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mn",null,"1"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(1)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"1"),a("span",{class:"mclose"},")")])])]),s("，而红黑树的查找、更新的时间复杂度是 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"l"),a("mi",null,"o"),a("msub",null,[a("mi",null,"g"),a("mn",null,"2")]),a("mtext",null,"⁡"),a("mi",null,"n"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(log_2⁡n )")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),a("span",{class:"mord mathnormal"},"o"),a("span",{class:"mord"},[a("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),a("span",{class:"msupsub"},[a("span",{class:"vlist-t vlist-t2"},[a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"0.3011em"}},[a("span",{style:{top:"-2.55em","margin-left":"-0.0359em","margin-right":"0.05em"}},[a("span",{class:"pstrut",style:{height:"2.7em"}}),a("span",{class:"sizing reset-size6 size3 mtight"},[a("span",{class:"mord mtight"},"2")])])]),a("span",{class:"vlist-s"},"​")]),a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"0.15em"}},[a("span")])])])])]),a("span",{class:"mord"},"⁡"),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mclose"},")")])])]),s("，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表")]),a("p",null,"​ 树化应是偶然情况，是保底策略"),a("p",null,"为什么树化的阈值是8？"),a("p",null,"​ 按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小"),a("p",null,"​ 提高了计算效率。table.length * 3/4可以被优化为((table.length >> 2) << 2) - (table.length >> 2) == table.length - ( table.length >> 2), JAVA的位运算比乘除的效率更高, 所以取3/4在保证hash冲突小的情况下兼顾了效率;"),a("p",null,"扩容时如何重新计算索引位置？"),a("p",null,"​ hash & oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap")],-1),m=a("h3",{id:"_3-索引计算规则",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_3-索引计算规则","aria-hidden":"true"},"#"),s(" 3.索引计算规则")],-1),u=a("p",null,"一共分为3步：",-1),d=a("ul",null,[a("li",null,"计算对象的 hashCode()"),a("li",null,[s("扰动计算，"),a("code",null,"(h = key.hashCode()) ^ (h >>> 16)")]),a("li",null,"上面的结果 & (capacity – 1) 得到索引")],-1),g=a("p",null,"hashCode()都有了，为什么还要提供hash方法（为什么还要进行扰动计算）？",-1),_=a("strong",null,"随机性",-1),x={href:"https://www.zhihu.com/question/20733617/answer/111577937",target:"_blank",rel:"noopener noreferrer"},f=l('<h3 id="_4-扩容流程" tabindex="-1"><a class="header-anchor" href="#_4-扩容流程" aria-hidden="true">#</a> 4.扩容流程</h3><p>默认容量为16</p><p>数组容量为什么必须是2的n次幂？</p><p>只有2的幂次方在减1的时候，才会出现<code>01111</code>这样的值。</p><p>2的n次幂有什么好坏处？</p><p>数组容量不是2的n次幂可不可以？</p><p>如果追求效率，应该用2的n次幂作为容量，这样可以保证最高位为1，这样可以通过位运算来计算hash值，而不是用取模运算，效率更高。</p><p>如果追求hash分布性，应该用质数作为容量，这样可以保证hash值分布更均匀，减少hash冲突，提高效率。</p>',8);function b(k,y){const e=r("ExternalLinkIcon");return n(),h("div",null,[c,p,m,u,d,a("blockquote",null,[g,a("p",null,[s("​ 简单来说就是混合了原哈希值中的高位和低位，增大了"),_,s(" ，可参考"),a("a",x,[s("JDK 源码中 HashMap 的 hash 方法原理是什么？"),o(e)])])]),f])}const v=t(i,[["render",b],["__file","jihe-map.html.vue"]]);export{v as default};
